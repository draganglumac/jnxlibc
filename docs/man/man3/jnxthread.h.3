.TH "jnxthread.h" 3 "Sat Jun 7 2014" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxthread.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <pthread\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_thread_attributes\fP"
.br
.ti -1c
.RI "struct \fBjnx_thread\fP"
.br
.ti -1c
.RI "struct \fBjnx_thread_mutex\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBjnx_thread_attributes\fP \fBjnx_thread_attributes\fP"
.br
.ti -1c
.RI "typedef void *( \fBentry_point\fP )(void *)"
.br
.ti -1c
.RI "typedef struct \fBjnx_thread\fP \fBjnx_thread\fP"
.br
.ti -1c
.RI "typedef struct \fBjnx_thread_mutex\fP \fBjnx_thread_mutex\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBjnx_thread_mutex\fP * \fBjnx_thread_mutex_create\fP ()"
.br
.ti -1c
.RI "void \fBjnx_thread_mutex_destroy\fP (\fBjnx_thread_mutex\fP **m)"
.br
.ti -1c
.RI "int \fBjnx_thread_unlock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.ti -1c
.RI "void \fBjnx_thread_lock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.RI "\fIblocking function that will wait for the mutex to unlock \fP"
.ti -1c
.RI "int \fBjnx_thread_trylock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.ti -1c
.RI "\fBjnx_thread\fP * \fBjnx_thread_create\fP (\fBentry_point\fP e, void *args)"
.br
.RI "\fIjnx_thread_create will create and start a new thread, adding to the pool \fP"
.ti -1c
.RI "int \fBjnx_thread_create_disposable\fP (\fBentry_point\fP e, void *args)"
.br
.RI "\fIjnx_thread_create will create and start a new thread but does not add to pool \fP"
.ti -1c
.RI "void \fBjnx_thread_handle_destroy\fP (\fBjnx_thread\fP *thr)"
.br
.ti -1c
.RI "int \fBjnx_thread_join\fP (\fBjnx_thread\fP *thr, void **data)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void*( entry_point)(void *)"

.SS "typedef struct \fBjnx_thread\fP \fBjnx_thread\fP"

.SS "typedef struct \fBjnx_thread_attributes\fP \fBjnx_thread_attributes\fP"

.SS "typedef struct \fBjnx_thread_mutex\fP \fBjnx_thread_mutex\fP"

.SH "Function Documentation"
.PP 
.SS "\fBjnx_thread\fP * jnx_thread_create (\fBentry_point\fPe, void *args)"

.PP
jnx_thread_create will create and start a new thread, adding to the pool 
.PP
\fBParameters:\fP
.RS 4
\fIentry_point\fP is the function pointer the thread starts with 
.br
\fIargs\fP are the arguments to pass the function pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBjnx_thread\fP object 
.RE
.PP

.SS "int jnx_thread_create_disposable (\fBentry_point\fPe, void *args)"

.PP
jnx_thread_create will create and start a new thread but does not add to pool 
.PP
\fBParameters:\fP
.RS 4
\fIentry_point\fP is the function pointer the thread starts with 
.br
\fIargs\fP are the arguments to pass the function pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
error code if any 
.RE
.PP

.SS "void jnx_thread_handle_destroy (\fBjnx_thread\fP *thr)"

.SS "int jnx_thread_join (\fBjnx_thread\fP *thr, void **data)"

.SS "jnx_thread_lock (\fBjnx_thread_mutex\fP *m)"

.PP
blocking function that will wait for the mutex to unlock 
.PP
\fBParameters:\fP
.RS 4
\fI\fBjnx_thread_mutex\fP\fP to lock 
.RE
.PP

.SS "\fBjnx_thread_mutex\fP* jnx_thread_mutex_create ()"

.SS "void jnx_thread_mutex_destroy (\fBjnx_thread_mutex\fP **m)"

.SS "int jnx_thread_trylock (\fBjnx_thread_mutex\fP *m)"

.SS "int jnx_thread_unlock (\fBjnx_thread_mutex\fP *m)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
